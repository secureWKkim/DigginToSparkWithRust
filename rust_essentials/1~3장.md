# 0. 기본 정보
snake case를 따른다. 따르지 않으면 컴파일러가 따르라고 알려준다.
<br><br>

# 1. 변수, 타입
## 사용법
```rust
// 1. immutable
let spaces = "   ";

// 2. mutable
let mut spaces = "   ";

// 3. shadowing
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
}

/* Rust 타입 종류, 구분
크게 scala, compound 둘로 구분된다.
*/
```

### 1) 어디에나 등장하는 타입 안정성 문제
python, ruby 와 같은 언어는 동적 타입(타입을 명시하지 않아도 알아서 타입을 추측해 처리해 줌)을, 자바 C++ 등의 언어는 정적 타입 언어다. 동적 타입 언어의 장단점은 각각 무엇일까? 동적 타입의 단점이, rust가 정적 타입을 지원하도록 만들어진 이유와 관련된다.
### 2) mutable vs immutable
이 둘을 따로 지원한다. 그럼 어떤 건 mut로 선언하고, 어떤건 반대로 선언할지에 대한 고민이 생길 텐데, 잣대가 될 만한 게 무엇일까?
### 3) null 문제를 어떻게 해결하는가
rust 변수의 기본이 불변 타입이며, 되도록이면 이를 강제하는 것 역시 NPE 발생을 예방하는 것과 관련 있다. 자바에서는 코딩 컨벤션 중 final 사용을 권장하거나, 8 버전 이후 Optional 을 지원하고, kotlin에서는 null을 허용하는 변수와 그렇지 않은 변수를 '?' 문법으로 구분 짓는 것 역시 이와 관련있다. 그렇다면 NPE 발생 문제는 왜 중요한 걸까? 이 문제는 DB, JSON을 다룰 때 많이 만날 수 있다.
### 4) *(pointer) 문법이 없다?
### 5) 32, 64 bit를 위한 타입을 모두 지원한다는 점에 대해
같은 문제를 nparray 에서도 접할 수 있다. 부동 소수점과 관련 되고, 이게 어떨 때 중요하게 작용할 수 있는지.
<br><br><br>

# 2. 함수
## 사용법
```rust
fn main() {
    let x = plus_one(5);
    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```
반환부에 return 선언문이나 ; 가 없다는 점에 주목하자. 또 파이썬에서도 "-> (타입 클래스)" 문법을 사용함으로써 타입 안정성을 확보하라는 권장 사항이 있는데, rust에서도 동일한 문법을 발견할 수 있다.

- call by value vs reference
rust로 만들어진 타 라이브러리 오픈소스들 보면서 알게된 것. 인자로 &를 전달하는 경우와 그렇지 않은 경우가 있는 건가? 이쪽에 대해 알아보자
<br><br><br>

# 3. 제어문
## 사용법
```rust
// 1. 조건문
    let number = 6;
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
// 아래와 같이 사용할 수도 있다.
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };
    println!("The value of number is: {}", number);


// 2. 반복문 3가지
// 1) for
for number in (1..4).rev() { //rev()는 reverse 기능
        println!("{}!", number);
    }
// 2) while
while number != 0 {
        println!("{}!", number);
        number = number - 1;
    }
// 3) loop
loop {
        println!("again!");
    }
```