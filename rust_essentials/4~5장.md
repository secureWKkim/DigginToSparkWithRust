# 4. 소유권, reference & borrowing, slicing
## 1) 소유권
rust의 가장 유니크한 특성이며, GC 없이 메모리 안정성을 보장하는 기반 원리이기 때문에 핵심이다. 아래는 핵심 특징 2가지.<br>
- 컴파일 타임에 컴파일러가 체크할 규칙들로 구성돼 있다.
- 힙 데이터 관리가 소유권의 존재 이유, 목적이다.
<br><br>


C++ 에서는 할당된 객체를 따로 해제해 주는 게 번거롭고 어렵다. 소유권 원칙은 scope와 drop 개념을 통해 알아서 값을 버려주기 때문에, 이런 부분을 신경 쓸 필요가 없다.
```text
1. 러스트의 각각의 값은 해당값의 오너(owner)라고 불리우는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재할 수 있다.
3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped).
```

이를 예시로 살펴 보면,
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게 이동시킵니다.
    let s2 = String::from("hello");     // s2가 스코프 안에 들어왔습니다.
    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로 이동되었고,
                                        // 이 함수가 반환값을 s3으로도 이동시켰습니다.
} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다.
  // s2는 스코프 밖으로 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다.
  // s1은 스코프 밖으로 벗어나서 drop이 호출됩니다.

fn gives_ownership() -> String {// gives_ownership 함수가 반환 값을 호출한 쪽으로 이동시킵니다.
    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.
    some_string                              // some_string이 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프 안으로 들어왔습니다.
    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
```
drop의 호출 = 값의 버려짐 = 힙 영역 할당 해제 의미 맞?
<br><br>

### 2) lifetime
컴파일러가 참조자의 유효성을 검증할 수 있도록 하기 위한 개념<br>


<br>

### 3) Slicing
- go, python과 비교한 slicing 기능
<br><br><br>

# 5. 구조체
마찬가지로 현대 언어의 일종인 kotlin에서는 data class가 비슷한 역할을 한다. go 도 그렇고, modern language는 왜 c/c++에 있던 구조체 개념을 다시 끌어 왔는가? 상당히 흥미로운 부분이 아닐 수 없다. 이는 OOP와 관련 된다.<br><br>
객체지향적이란게 무엇인가? 응집도는 높고 결합도는 낮은 것을 의미한다. 구조체와 함수를 사용함으로써 오히려 C++, Java같은 전통적 객체지향 언어보다 더 제대로 객체지향성을 꾀할 수 있다는 역설이 있다. 왜 역설인가? 구조체는 OOP의 등장 전 절차 지향, 데이터 지향을 대표하는 문법 중 하나이기 때문이다.<br><br>